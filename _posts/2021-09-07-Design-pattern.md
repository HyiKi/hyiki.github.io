---
title: Java设计模式学习路线
date:  	2021-09-07 08:56:36 +0800
category: Original
tags: Java
excerpt: Java设计模式学习路线
---

* content
{:toc}

# Java设计模式学习路线

## 创建型

### 传统实现

* 工厂模式  

 	* if-else 或者 switch-case语句根据不同的值返回不同的对象  

* bean工厂(Spring IOC)  

 	* 类似于工厂模式，通过getBean(id)方法从IOC容器中获取对象  

### 类模式

* 工厂方法模式  

 	* 将生产产品的方法抽象化，将其延迟到子类实现  

  		* 单一职责原则、开闭原则、平台代码不用关心具体代码实现  

### 对象模式

* 单例模式  

 	* 饿汉式  

 	* Double-check懒汉式  

  		* volatile易变关键字防止指令重排  

 	* 静态内部类懒汉式  

  		* 构造方法null判空防止反射  

  		* 实现readSolve方法防止反序列化单例破坏  

 	* 枚举  

* 原型模式  

 	* 快速复制已有对象，代码无需依赖他们所属的类  

  		* 实现Cloneable接口达到浅/深拷贝的效果  

  		* 序列化、反序列化实现深拷贝的效果（不推荐，流操作消耗CPU性能）  

* 抽象工厂模式  

 	* 将生产一系列产品的方法接口化：接口类  

  		* 单一职责原则、开闭原则、平台代码不用关心具体代码实现  

* 建造者模式  

 	* 建造者类只需要关注生产者类，生产者类实现生产产品接口  

  		* 适用于复杂对象，独立易扩展，便于控制细节  

   			* 建造者1：建造者接口类  

   			* 变种建造者2：静态内部类  

## 结构型

### 类模式

* 类适配器模式  

 	* 与对象适配器模式类似，但是用extends实现的方式不符合迪米特法则（最少知道法则）  

### 对象模式

* 代理模式  

 	* 静态代理  

  		* 与被代理类实现同一接口，通过构造器传入被代理类来增强其方法，例如日志打印、时间统计等  

 	* 动态代理  

  		* 通过传入InvocationHandler策略调用Proxy创建代理实例的方法实现动态代理(被代理类必须实现接口)  

 	* Cglib代理  

  		* 创建一个Enhancer对象，设置其父类为被代理类的class，其callback为MethodInterceptor策略，调用create方法实现动态代理(*被代理类不需要实现接口)  

 	* 面向切面编程(Spring AOP)  

  		* xml实现  

  		* @注解实现  

   			* xml文件添加自动构建代理，且开启Cglib  
   			* &amp;lt;aop:aspectj-autoproxy proxy-target-class=&amp;quot;true&amp;quot;/&amp;gt;  

   			* @Aspect切面  

   			* @Before在目标方法被调用之前做增强  

   			* @AfterReturning在目标方法正常完成后做增强  

   			* @AfterThrowing在目标方法抛出异常后做增强  

   			* @After在目标方法调用完成之后做增强  

   			* @Around环绕通知,在目标方法调用前后做增强  

* 对象适配器模式  

 	* 当前对象与现有代码不兼容时，多个子类兼容超类有共同方法时  

* 桥接模式  

 	* 将事物的抽象和具体进行分离，避免类数量的爆炸  

* 装饰器模式  

 	* 在不需要对当前类代码修改的情况下扩展功能，通过组合的方式能实现不同的扩展功能  

* 外观模式  

 	* 方便客户端调用服务端的复杂子系统  

* 享元模式  

 	* 控制粒子系统中大量类似的对象  

  		* 原系统中有大量类似的粒子对象时，可以节省CPU和内存资源  

* 组合模式  

 	* 用于树状结构的构建，节点对象可以独立使用  

  		* 举例：AB 由 A，B组成，Chapter由Section组成  

## 行为型

### 类模式

* 模板方法模式  

 	* 与工厂方法模式类似，但是工厂方法是返回产品对象，模板方法模式更偏向于算法方法调用  

 	* 定义一个算法的骨架，将一些特定的步骤延迟到子类  

### 对象模式

* 观察者模式  

 	* 定义对象之间一对多的关系，将多个观察者同时监听同一个主题对象，当主题对象触发提醒时，通知并更新所有观察者  

* 策略模式  

 	* 定义一个算法族，族里的行为可以相互替换  

* 责任链模式  

 	* 构建一个请求对象和单个或多个处理器对象，处理器以链式存储（可以是数组，也可以是链表），这样请求可以被处理器有序地处理  

* 迭代器模式  

 	* 迭代器模式提供next和hasNext方法，使用举例可见List类的iterator()方法  

* 命令模式  

 	* 命令模式接口提供执行和撤回的方法，例如工具栏的按钮就是命令模式的实例  

* 中介者模式  

 	* 调解类与类之间的关系，起到解耦的作用  

* 状态模式  

 	* 根据状态决定行为，与策略模式的区别在于，状态模式行为过程中可以切换状态，而策略之间是互不关联的  

* 解释器模式  

 	* 略  

* 备忘录模式  

 	* 记录快照，恢复备份  

* 访问者模式  

 	* 在不修改原有代码结构的情况下，动态修改类的元素值  
